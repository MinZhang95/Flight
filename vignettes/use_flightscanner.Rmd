---
title: "FlightScanner: Find the best flight for you!"
output: 
    rmarkdown::html_vignette:
       
author: Yang Qiao, Dapeng Hu, Min Zhang, Xin Zhang and Zerui Zhang
date: "5/7/2019"
vignette: >
  %\VignetteIndexEntry{FlightScanner}
  %\VignetteEngine{knitr::rmarkdown}
  %\VignetteEncoding{UTF-8}
---

```{r, include=FALSE, message=FALSE}
library(dplyr)
library(httr)
```
## Introduction

(a paragraph to introduce the motivation and what we want to do,)

Finding the cheapest flight from point A to point B can be a headache for most of us, especially with other multiple constraints, such as duration, departure and arrival time, layover, etc. The flight searching engines do not provide detailed enough filters for those “picky” customers, and it’s also time consuming to constantly check the flight information. Our project (R package) allows us to scrape information from Skyscanner API, and keep track of that per unit time. The functions in our package also enable us to filter and sort the available flights based on customized constraints. Outcomes are presented with both text and user-friendly figures. Finally, we build a Shiny web page to make flight searching process easy and fun.


```{r, include = FALSE}
knitr::opts_chunk$set(
  collapse = TRUE,
  comment = "#>",
  fig.align = "center"
)
```

## Getting Started

(introdue how to install our package and the api our package based on)

```{r}
library(flightscanner)
```
```{r,echo=FALSE}
apiSetKey("a01b3ec5e9msh2698ef80ca5232dp18fc92jsnddf5fad0cc7d")
```

(introduce the dataset Airport in our package and show some plots and tables)

### Setup with API key

#### `apiCheckKey`

To explore the features of our package, the API key is necessary. After loading **'flightscanner'**, the following function will be triggered if the API key is not provided. 
```r
flightscanner::apiCheckKey()
```

It is based on the R function "onAttach". Thus, it will be called with
```r
library(flightscanner)
```
but not run with
```r
flightscanner::some_function
```

Two questions will be posted for users to easily setup the API:
```r
API key is required!
Please follow the instructions to get the key:
1. Browse and login:  https://rapidapi.com/skyscanner/api/skyscanner-flight-search 
   Do you want to visit this website (1 for YES; 0 for NO)?
   
2. Copy the value of X-RapidAPI-Key in Header Parameters.
   Paste your key (without quote):
   
```
If the users enter "1" for the first question, the webpage of Rapid API will be opened and users can find the API key in the right panel(See the below figure); then users can paste the key for the second question and the API option will be automatically setup. 

```{r, out.width='100%', echo=FALSE, eval=TRUE}
knitr::include_graphics('APIwebpage.JPG')
```

Some messages will be posted to show whether the API setup is successful or not. If the key is invalid or the network is unconnected, it will show that
```r
Check your key or network connection. And use function `apiSetKey` to set key later.
```
If it successed, the welcome message will be shown:
```r
Welcome to FlightScanner!
```
The API key will be stored into "APIkey.txt" under the current working directory

#### `setAPI`

In addition, the users can reset the API key globally with the function 'apiSetKey'
```r
flightscanner::apiSetKey("YOUR KEY")
```
However, this function will NOT generate or rewrite 'APIkey.txt' under the current working directory.

To get the global API, the function 'apiGetKey' can be adopted:
```r
fligthscanner::apiGetKey()
```
This function will return the key if it has been set, otherwise 'NULL'.

## Main Functions

### Download data with API

#### `apiCreateSession`

`apiCreateSession` allows users to input their searching information such as origin, destination, etc, and create a session on the API server, then return an ouput which contains a session ID. For example, if you want to buy 1 adult flight ticket flying from Des Moines to Seattle on 2019-07-20 (make sure the date you input is on or after your current date).

```{r}
dsm2sea_session <- apiCreateSession(origin = "DSM", destination = "SEA", startDate = "2019-07-20", adults = 1)
```

We will use the output from `apiCreateSession` as the input of `apiPollSession`

#### `apiPollSession`

`apiPollSession` retrieves the flight data you searched in `apiCreateSession` and also allows you to sort the results by different types like price, duration. Filters like number of stops, departure time are also available. The default values of all filter variables are `NULL` because we usually do not filter anything before we can see the actual data. Let's say if we want our search result in price ascending order. 

```{r}
dsm2sea_res <- apiPollSession(response = dsm2sea_session, sortType = "price", sortOrder = "asc")
```

We can check the content of the output of `apiPollSession`.

```{r}
dsm2sea_res %>% content %>% names
```

Although output from `apiPollSession` is the searching result, the format of it is not very friendly. The output contains several sub-lists such as "itineraries", "legs", "segments". The relationship between these terms are shown below.

$$
\text{searching result} 
\begin{cases}
  \text{itinerary_1} 
    \begin{cases}
      \text{leg_1} 
        \begin{cases}
          \text{segment_1} \\
          \text{segment_2} \\
          \vdots \\
          \text{segment_S}
        \end{cases} \\
      \text{leg_2} 
        \begin{cases}
          \text{segment_1}
        \end{cases}
    \end{cases} \\
  \text{itinerary_2} 
    \begin{cases}
      \text{leg_1} 
        \begin{cases}
          \text{segment_1} \\
          \text{segment_2} 
        \end{cases} \\
      \text{leg_2} 
        \begin{cases}
          \text{segment_1}
        \end{cases}
    \end{cases} \\
  \vdots \\
  \text{itinerary_n} 
    \begin{cases}
      \text{leg_1} 
        \begin{cases}
          \text{segment_1} 
        \end{cases} \\
      \text{leg_2} 
        \begin{cases}
          \text{segment_1}
        \end{cases}
    \end{cases}
\end{cases}
$$
Searching results may contain many itineraries. Round-way trip contains two legs, outbound leg and inbound leg. If there are any stops in one leg, then this leg may contain several segments. Next we are going to link them and store them effeciently.

### Data Processing 

#### `flightGet`

`flightGet` allows users to input the result from `PollSession` or read from database (will talk about this later in "Data Storage" section) and get a list which contains 7 dataframes. The names of these dataframes are shown below.

```{r}
dsm2sea_df <- dsm2sea_res %>% flightGet()
names(dsm2sea_df)
```

The dataframe "price" contains information like seraching time and pricing option.

```{r}
dsm2sea_df$price %>% head(3) %>% print(width = 120)
```

Even the same itinerary may have different prices because of different agents.

```{r}
dsm2sea_df$price$PricingOptions[[3]] %>% head(3) %>% print(width = 120)
```

Dataframe "leg" has information like duration and number of stops.

```{r}
dsm2sea_df$legs %>% head(3) %>% print(width = 120)
```

We can also check the stop information in dataframe "leg". Let's say we want to look at stops and layover for each leg. Note the unit of layover is minute.

```{r}
dsm2sea_df$legs$Stops %>% head(3) %>% print(width = 120)
```

Similarly, detailed results about segments are stored in dataframe "segments".

```{r}
dsm2sea_df$segments %>% head(2) %>% print(width = 120)
```

Note that information like "StopId" and "CarrierId" is numbers. The next three tables contain these IDs and corresponding names.

```{r}
dsm2sea_df$carriers %>% head(1) %>% print(width = 120)
dsm2sea_df$agents %>% head(1) %>% print(width = 120)
dsm2sea_df$places %>% head(1) %>% print(width = 120)
```

#### `flightFilter`

Users can use `flightFilter` to filter the results they get from `flightGet`. Suppose the maximum price we would like to pay is $1,000 and we want the number of stops is less than 1. Moreover, we want to depart after 8:00 am.

```{r}
flightFilter(dsm2sea_df, max_price = 1000, max_stops = 1, out_departure = c("08:00","24:00")) %>% head(3)
```

### Data Storage

We want to scrape and save data for a period to see the price change over time. Thus, here several functions are made to generate database.

#### `dbCreateDB`

**'dbCreateDB'** is a function to connect to SQLite driver and generate a local database file 'flight.db'.
```r
dbCreateDB(conn = RSQLite::SQLite(), dbname = "flight.db")
```
The flight.db includes 7 tables:
```{r,echo=FALSE}
con <- dbCreateDB(dbname = "flight.db")
dbListTables(con)
```

#### `dbSaveData`

**'dbSaveDB'** is a function to save data from the request response into the databse 'flight.db'. 
```r
resp <- apiCreateSession(origin = "SFO", destination = "LHR", startDate = "2019-07-01")
resp <- apiPollSession(resp)
data <- flightGet(resp)

# Connect to SQLite database
con <- dbCreateDB(dbname = ":memory:")
dbSaveData(resp, con)  # from response
dbSaveData(data, con)  # from list
dbDisconnect(con)
```

## Automatical Download Data

The **flightscanner** is a 'mature' paakage, and it can download the flight data by itself. Based on the package **'cronR'**, we make the function **'cron_create'**. 

The following arguments are required for **'cron_create'**:  
- origin: The origin place;  
- destination: The destination;  
- startDate: The leaving date;  
- returnDate: The return date (default is 'NULL');  
- frequency: How frequent the auto-searching is. It could be "minutely", "hourly", "daily" or any time period based on cronR's syntax.

We give some examples here:
```r
cron_create("SFO", "LHR", "2019-07-01", frequency = "daily", at = "3AM")
cron_create("SFO", "LHR", "2019-07-01", "2019-07-10", frequency = "hourly")
cron_create("SFO", "LHR", "2019-07-01", frequency = "minutely")
cron_create("SFO", "LHR", "2019-07-01", frequency = "0 */2 * * *")  # every 2 hours
```
Two files will be generated:  
- log file: 'script_origin_destination_startDate_returnDate.log';  
- database: 'flight.db'.

The log file includes the searching message. For example,
```r
Time: 2019-05-05 09:00:00
Welcome to FlightScanner!
Working Directory: /working directory
API Key: XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX
Command Line Arguments:  DSM DTW 2019-06-01 
Try to update data 16 times.
Warning message:
Unmatch of Segments and Stops: [LegId] = 11140-1906010743--30963,-32462-3-11152-1906020959 
```
In the 'flight.db', all the search results are contained.
```{r}
# connect to SQLite database
con <- dbCreateDB(dbname = "flight.db")
# read data from database
data <- flightGet(con)  
# show the searching time
unique(data$price$SearchTime)
# disconnect database
dbDisconnect(con)
```

To show the current searching jobs, use the function:
```r
cron_ls()
```
To clear the current searching jobs, use the function:
```r
cron_clear(ask = FALSE)
```

