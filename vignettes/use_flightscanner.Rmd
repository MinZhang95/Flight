---
title: "FlightScanner: Find the best flight for you!"
output: 
    rmarkdown::html_vignette:
      toc: true
       
author: Yang Qiao, Dapeng Hu, Min Zhang, Xin Zhang and Zerui Zhang
date: "5/7/2019"
vignette: >
  %\VignetteIndexEntry{FlightScanner}
  %\VignetteEngine{knitr::rmarkdown}
  %\VignetteEncoding{UTF-8}
---

```{r, include=FALSE, message=FALSE}
library(dplyr)
library(httr)
```
## Introduction

(a paragraph to introduce the motivation and what we want to do,)

Finding the cheapest flight from point A to point B could be a headache for many of us, especially with other multiple constraints, such as duration, departure and arrival time, layover, etc. The goal of the `FlightScanner` package is to provide a simple and straightforward interface for interacting with [Rapid API--Sky Scanner](https://rapidapi.com/skyscanner/api/skyscanner-flight-search) through R. The Sky Scanner API lets users to search for flight and query flight prices from Skyscanners database, as well as quotes from ticketing agencies.  Besides these basic functionalities as a flight searching tool, `FlightScanner` allows users to schedule searches and record results antomatically. The package also provides a Shiny APP to visualize the trip and to show the available ticket options according to the customized constraints. 


```{r, include = FALSE}
knitr::opts_chunk$set(
  collapse = TRUE,
  comment = "#>",
  fig.align = "center"
)
```

## Getting Started

(introdue how to install our package and the api our package based on)
To install the `flightscanner` package, run:

```{r message=FALSE}
devtools::install_github("MinZhang95/flightscanner")
```

```{r}
library(flightscanner)
```
```{r,echo=FALSE}
apiSetKey("a01b3ec5e9msh2698ef80ca5232dp18fc92jsnddf5fad0cc7d")
```

(introduce the dataset Airport in our package and show some plots and tables)

### Setup with API key

#### `apiCheckKey`

To explore the features of our package, the API key is necessary. After loading **'flightscanner'**, the following function will be triggered if the API key is not provided. 
```r
flightscanner::apiCheckKey()
```

It is based on the R function "onAttach". Thus, it will be called with
```r
library(flightscanner)
```
but not run with
```r
flightscanner::some_function
```

Two questions will be posted for users to easily setup the API:
```r
API key is required!
Please follow the instructions to get the key:
1. Browse and login:  https://rapidapi.com/skyscanner/api/skyscanner-flight-search 
   Do you want to visit this website (1 for YES; 0 for NO)?
   
2. Copy the value of X-RapidAPI-Key in Header Parameters.
   Paste your key (without quote):
   
```
If the users enter "1" for the first question, the webpage of Rapid API will be opened and users can find the API key in the right panel(See the below figure); then users can paste the key for the second question and the API option will be automatically setup. 

```{r, out.width='100%', echo=FALSE, eval=TRUE}
knitr::include_graphics('APIwebpage.JPG')
```

Some messages will be posted to show whether the API setup is successful or not. If the key is invalid or the network is unconnected, it will show that
```r
Check your key or network connection. And use function `apiSetKey` to set key later.
```
If it successed, the welcome message will be shown:
```r
Welcome to FlightScanner!
```
The API key will be stored into "APIkey.txt" under the current working directory

#### `setAPI`

In addition, the users can reset the API key globally with the function 'apiSetKey'
```r
flightscanner::apiSetKey("YOUR KEY")
```
However, this function will NOT generate or rewrite 'APIkey.txt' under the current working directory.

To get the global API, the function 'apiGetKey' can be adopted:
```r
fligthscanner::apiGetKey()
```
This function will return the key if it has been set, otherwise 'NULL'.

## Main Functions

### Download data with API

#### `apiCreateSession`

`apiCreateSession` allows users to input their searching information such as origin, destination, etc, and create a session on the API server, then return an ouput which contains a session ID. For example, if you want to buy 1 adult flight ticket flying from Des Moines to Seattle on 2019-07-20 (make sure the date you input is on or after your current date).

```{r}
dsm2sea_session <- apiCreateSession(origin = "DSM", destination = "SEA", startDate = "2019-07-20", adults = 1)
```

We will use the output from `apiCreateSession` as the input of `apiPollSession`

#### `apiPollSession`

`apiPollSession` retrieves the flight data you searched in `apiCreateSession` and also allows you to sort the results by different types like price, duration. Filters like number of stops, departure time are also available. The default values of all filter variables are `NULL` because we usually do not filter anything before we can see the actual data. Let's say if we want our search result in price ascending order. 

```{r}
dsm2sea_res <- apiPollSession(response = dsm2sea_session, sortType = "price", sortOrder = "asc")
```

We can check the content of the output of `apiPollSession`.

```{r}
dsm2sea_res %>% content %>% names
```

Although output from `apiPollSession` is the searching result, the format of it is not very friendly. The output contains several sub-lists such as "itineraries", "legs", "segments". The relationship between these terms are shown below.

$$
\text{searching result} 
\begin{cases}
  \text{itinerary_1} 
    \begin{cases}
      \text{leg_1} 
        \begin{cases}
          \text{segment_1} \\
          \text{segment_2} \\
          \vdots \\
          \text{segment_S}
        \end{cases} \\
      \text{leg_2} 
        \begin{cases}
          \text{segment_1}
        \end{cases}
    \end{cases} \\
  \text{itinerary_2} 
    \begin{cases}
      \text{leg_1} 
        \begin{cases}
          \text{segment_1} \\
          \text{segment_2} 
        \end{cases} \\
      \text{leg_2} 
        \begin{cases}
          \text{segment_1}
        \end{cases}
    \end{cases} \\
  \vdots \\
  \text{itinerary_n} 
    \begin{cases}
      \text{leg_1} 
        \begin{cases}
          \text{segment_1} 
        \end{cases} \\
      \text{leg_2} 
        \begin{cases}
          \text{segment_1}
        \end{cases}
    \end{cases}
\end{cases}
$$
Searching results may contain many itineraries. Round-way trip contains two legs, outbound leg and inbound leg. If there are any stops in one leg, then this leg may contain several segments. Next we are going to link them and store them effeciently.

### Data Processing 

#### `flightGet`

`flightGet` allows users to input the result from `PollSession` or read from database (will talk about this later in "Data Storage" section) and get a list which contains 7 dataframes. The names of these dataframes are shown below.

```{r}
dsm2sea_df <- dsm2sea_res %>% flightGet()
names(dsm2sea_df)
```

The dataframe "price" contains information like seraching time and pricing option.

```{r}
dsm2sea_df$price %>% head(3) %>% print(width = 120)
```

Even the same itinerary may have different prices because of different agents.

```{r}
dsm2sea_df$price$PricingOptions[[3]] %>% head(3) %>% print(width = 120)
```

Dataframe "leg" has information like duration and number of stops.

```{r}
dsm2sea_df$legs %>% head(3) %>% print(width = 120)
```

We can also check the stop information in dataframe "leg". Let's say we want to look at stops and layover for each leg. Note the unit of layover is minute.

```{r}
dsm2sea_df$legs$Stops %>% head(3) %>% print(width = 120)
```

Similarly, detailed results about segments are stored in dataframe "segments".

```{r}
dsm2sea_df$segments %>% head(2) %>% print(width = 120)
```

Note that information like "StopId" and "CarrierId" is numbers. The next three tables contain these IDs and corresponding names.

```{r}
dsm2sea_df$carriers %>% head(1) %>% print(width = 120)
dsm2sea_df$agents %>% head(1) %>% print(width = 120)
dsm2sea_df$places %>% head(1) %>% print(width = 120)
```

#### `flightFilter`

Users can use `flightFilter` to filter the results they get from `flightGet`. Suppose the maximum price we would like to pay is $1,000 and we want the number of stops is less than 1. Moreover, we want to depart after 8:00 am.

```{r}
flightFilter(dsm2sea_df, max_price = 1000, max_stops = 1, out_departure = c("08:00","24:00")) %>% head(3)
```

### Data Storage

We want to scrape and save data for a period to see the price change over time. Thus, here several functions are made to generate database.

#### `dbCreateDB`

**'dbCreateDB'** is a function to connect to SQLite driver and generate a local database file 'flight.db'.
```r
dbCreateDB(conn = RSQLite::SQLite(), dbname = "flight.db")
```
The flight.db includes 7 tables:
```{r,echo=FALSE}
con <- dbCreateDB(dbname = "flight.db")
dbListTables(con)
```

#### `dbSaveData`

**'dbSaveDB'** is a function to save data from the request response into the databse 'flight.db'. 
```r
resp <- apiCreateSession(origin = "SFO", destination = "LHR", startDate = "2019-07-01")
resp <- apiPollSession(resp)
data <- flightGet(resp)

# Connect to SQLite database
con <- dbCreateDB(dbname = ":memory:")
dbSaveData(resp, con)  # from response
dbSaveData(data, con)  # from list
dbDisconnect(con)
```

## Automatical Download Data

The **flightscanner** is a 'mature' paakage, and it can download the flight data by itself. Based on the package **'cronR'**, we make the function **'cron_create'**. 

The following arguments are required for **'cron_create'**:  
- origin: The origin place;  
- destination: The destination;  
- startDate: The leaving date;  
- returnDate: The return date (default is 'NULL');  
- frequency: How frequent the auto-searching is. It could be "minutely", "hourly", "daily" or any time period based on cronR's syntax.

We give some examples here:
```r
cron_create("SFO", "LHR", "2019-07-01", frequency = "daily", at = "3AM")
cron_create("SFO", "LHR", "2019-07-01", "2019-07-10", frequency = "hourly")
cron_create("SFO", "LHR", "2019-07-01", frequency = "minutely")
cron_create("SFO", "LHR", "2019-07-01", frequency = "0 */2 * * *")  # every 2 hours
```
Two files will be generated:  
- log file: 'script_origin_destination_startDate_returnDate.log';  
- database: 'flight.db'.

The log file includes the searching message. For example,
```r
Time: 2019-05-05 09:00:00
Welcome to FlightScanner!
Working Directory: /working directory
API Key: XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX
Command Line Arguments:  DSM DTW 2019-06-01 
Try to update data 16 times.
Warning message:
Unmatch of Segments and Stops: [LegId] = 11140-1906010743--30963,-32462-3-11152-1906020959 
```
In the 'flight.db', all the search results are contained.
```{r}
# connect to SQLite database
con <- dbCreateDB(dbname = "flight.db")
# read data from database
data <- flightGet(con)  
# show the searching time
unique(data$price$SearchTime)
# disconnect database
dbDisconnect(con)
```

To show the current searching jobs, use the function:
```r
cron_ls()
```
To clear the current searching jobs, use the function:
```r
cron_clear(ask = FALSE)
```

## Instruction to using the Shiny App

The Shiny App for the `flightscanner` has mainly three tabs: **Airport Map**, **Flights** and **IATA Code**.

### Airport Map

It is set to the welcome page by default. The map from `leaflet` would show the accurate position of the ariport you choose. It could provide a rough intuition that how far the user would need to travel.

There are four input boxes on the top of the map. If the user wants to make a flight search, these values should be provided.

**Trip type**: one-way tirp or round trip.

**From**, **To**: 3-character code for the airports the user would like to start from and end at.

**Dept.Date**, **Arr.Date**: small calendar would be shown so that the user could choose the specific date for leaving and arriving. **Arr.Date** box would appear only when the user choose a **round trip**.

After the user makes sure that the App has been given the right information, he/she can click the **Go!** button with the cute paper plane and then wait for the data scrape, cleaning and filtering.

```{r, out.width='100%', echo=FALSE, eval=TRUE}
knitr::include_graphics('shiny2.png')
```

### Flights

Once the App indicates that "Search succeeded! Click Flight Tab For More Details:)", the user could then have a check on this module.

There are several filter options on the left panel.

**Price**: a slider ranging from the maximum to the minimum of the ticket price.

**Airlines Includes**, **Airlines Excludes**: the user can delete or keep the airlines that you want to include or exclude.

**Duration**: the time required for a specific flight.

**Stops**: the user can choose the preferences for the number of transit stops.

**Layover**: the total time the user will spend at the transit stops.

**Outbound, Inbound**: the user could choose the specific range of time for the departure time and arrival time, for both outbound flight and inbound flight using a 24-hour clock.

```{r, out.width='100%', echo=FALSE, eval=TRUE}
knitr::include_graphics('shiny3.png')
```

A datatable containing some important and detailed inforamtion about the filtered filghts would be given on the right panel, including accurate total price, leaving and arriving time for inbound and/or outbound flight, duration and number of stops of inbound and/or outbound. There is also hyperlinks for the ticket booking on the agent websites in the column of **Link**.

### IATA Code

If the user has no idea what the 3-character codes for the airports he/she would visit, this tab could help find the codes. Use the search box on the right and feed it with the name of the city or country, the data from `MUCflight` would provide the desired information.

